{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValConsAddress = exports.ValPubKey = exports.ValAddress = exports.AccPubKey = exports.AccAddress = void 0;\n\nvar bech32_1 = require(\"bech32\");\n\nfunction checkPrefixAndLength(prefix, data, length) {\n  try {\n    var vals = bech32_1.bech32.decode(data);\n    return vals.prefix === prefix && data.length == length;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar AccAddress;\n\n(function (AccAddress) {\n  /**\n   * Checks if a string is a valid Terra account address.\n   *\n   * @param data string to check\n   */\n  function validate(data) {\n    return checkPrefixAndLength('terra', data, 44);\n  }\n\n  AccAddress.validate = validate;\n  /**\n   * Converts a validator address into an account address\n   *\n   * @param address validator address\n   */\n\n  function fromValAddress(address) {\n    var vals = bech32_1.bech32.decode(address);\n    return bech32_1.bech32.encode('terra', vals.words);\n  }\n\n  AccAddress.fromValAddress = fromValAddress;\n})(AccAddress = exports.AccAddress || (exports.AccAddress = {}));\n\nvar AccPubKey;\n\n(function (AccPubKey) {\n  /**\n   * Checks if a string is a Terra account's public key\n   * @param data string to check\n   */\n  function validate(data) {\n    return checkPrefixAndLength('terrapub', data, 47);\n  }\n\n  AccPubKey.validate = validate;\n  /**\n   * Converts a Terra validator pubkey to an account pubkey.\n   * @param address validator pubkey to convert\n   */\n\n  function fromAccAddress(address) {\n    var vals = bech32_1.bech32.decode(address);\n    return bech32_1.bech32.encode('terrapub', vals.words);\n  }\n\n  AccPubKey.fromAccAddress = fromAccAddress;\n})(AccPubKey = exports.AccPubKey || (exports.AccPubKey = {}));\n\nvar ValAddress;\n\n(function (ValAddress) {\n  /**\n   * Checks if a string is a Terra validator address.\n   *\n   * @param data string to check\n   */\n  function validate(data) {\n    return checkPrefixAndLength('terravaloper', data, 51);\n  }\n\n  ValAddress.validate = validate;\n  /**\n   * Converts a Terra account address to a validator address.\n   * @param address account address to convert\n   */\n\n  function fromAccAddress(address) {\n    var vals = bech32_1.bech32.decode(address);\n    return bech32_1.bech32.encode('terravaloper', vals.words);\n  }\n\n  ValAddress.fromAccAddress = fromAccAddress;\n})(ValAddress = exports.ValAddress || (exports.ValAddress = {}));\n\nvar ValPubKey;\n\n(function (ValPubKey) {\n  /**\n   * Checks if a string is a Terra validator pubkey\n   * @param data string to check\n   */\n  function validate(data) {\n    return checkPrefixAndLength('terravaloperpub', data, 54);\n  }\n\n  ValPubKey.validate = validate;\n  /**\n   * Converts a Terra validator operator address to a validator pubkey.\n   * @param valAddress account pubkey\n   */\n\n  function fromValAddress(valAddress) {\n    var vals = bech32_1.bech32.decode(valAddress);\n    return bech32_1.bech32.encode('terravaloperpub', vals.words);\n  }\n\n  ValPubKey.fromValAddress = fromValAddress;\n})(ValPubKey = exports.ValPubKey || (exports.ValPubKey = {}));\n\nvar ValConsAddress;\n\n(function (ValConsAddress) {\n  /**\n   * Checks if a string is a Terra validator consensus address\n   * @param data string to check\n   */\n  function validate(data) {\n    return checkPrefixAndLength('terravalcons', data, 51);\n  }\n\n  ValConsAddress.validate = validate;\n})(ValConsAddress = exports.ValConsAddress || (exports.ValConsAddress = {}));","map":{"version":3,"mappings":"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","names":["checkPrefixAndLength","prefix","data","length","vals","bech32_1","decode","e","AccAddress","validate","fromValAddress","address","encode","words","exports","AccPubKey","fromAccAddress","ValAddress","ValPubKey","valAddress","ValConsAddress"],"sources":["../../src/core/bech32.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}