{"ast":null,"code":"const BN = require('bn.js');\n\nconst EC = require('elliptic').ec;\n\nconst secp256k1 = new EC('secp256k1');\n\nconst deterministicGenerateK = require('./rfc6979');\n\nconst ZERO32 = Buffer.alloc(32, 0);\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\nconst EC_P = Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex');\nconst n = secp256k1.curve.n;\nconst nDiv2 = n.shrn(1);\nconst G = secp256k1.curve.g;\nconst THROW_BAD_PRIVATE = 'Expected Private';\nconst THROW_BAD_POINT = 'Expected Point';\nconst THROW_BAD_TWEAK = 'Expected Tweak';\nconst THROW_BAD_HASH = 'Expected Hash';\nconst THROW_BAD_SIGNATURE = 'Expected Signature';\nconst THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)';\n\nfunction isScalar(x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\n\nfunction isOrderScalar(x) {\n  if (!isScalar(x)) return false;\n  return x.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\nfunction isPoint(p) {\n  if (!Buffer.isBuffer(p)) return false;\n  if (p.length < 33) return false;\n  const t = p[0];\n  const x = p.slice(1, 33);\n  if (x.compare(ZERO32) === 0) return false;\n  if (x.compare(EC_P) >= 0) return false;\n\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    try {\n      decodeFrom(p);\n    } catch (e) {\n      return false;\n    } // TODO: temporary\n\n\n    return true;\n  }\n\n  const y = p.slice(33);\n  if (y.compare(ZERO32) === 0) return false;\n  if (y.compare(EC_P) >= 0) return false;\n  if (t === 0x04 && p.length === 65) return true;\n  return false;\n}\n\nfunction __isPointCompressed(p) {\n  return p[0] !== 0x04;\n}\n\nfunction isPointCompressed(p) {\n  if (!isPoint(p)) return false;\n  return __isPointCompressed(p);\n}\n\nfunction isPrivate(x) {\n  if (!isScalar(x)) return false;\n  return x.compare(ZERO32) > 0 && // > 0\n  x.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\nfunction isSignature(value) {\n  const r = value.slice(0, 32);\n  const s = value.slice(32, 64);\n  return Buffer.isBuffer(value) && value.length === 64 && r.compare(EC_GROUP_ORDER) < 0 && s.compare(EC_GROUP_ORDER) < 0;\n}\n\nfunction assumeCompression(value, pubkey) {\n  if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey);\n  if (value === undefined) return true;\n  return value;\n}\n\nfunction fromBuffer(d) {\n  return new BN(d);\n}\n\nfunction toBuffer(d) {\n  return d.toArrayLike(Buffer, 'be', 32);\n}\n\nfunction decodeFrom(P) {\n  return secp256k1.curve.decodePoint(P);\n}\n\nfunction getEncoded(P, compressed) {\n  return Buffer.from(P._encode(compressed));\n}\n\nfunction pointAdd(pA, pB, __compressed) {\n  if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT);\n  if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT);\n  const a = decodeFrom(pA);\n  const b = decodeFrom(pB);\n  const pp = a.add(b);\n  if (pp.isInfinity()) return null;\n  const compressed = assumeCompression(__compressed, pA);\n  return getEncoded(pp, compressed);\n}\n\nfunction pointAddScalar(p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);\n  const compressed = assumeCompression(__compressed, p);\n  const pp = decodeFrom(p);\n  if (tweak.compare(ZERO32) === 0) return getEncoded(pp, compressed);\n  const tt = fromBuffer(tweak);\n  const qq = G.mul(tt);\n  const uu = pp.add(qq);\n  if (uu.isInfinity()) return null;\n  return getEncoded(uu, compressed);\n}\n\nfunction pointCompress(p, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);\n  const pp = decodeFrom(p);\n  if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT);\n  const compressed = assumeCompression(__compressed, p);\n  return getEncoded(pp, compressed);\n}\n\nfunction pointFromScalar(d, __compressed) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);\n  const dd = fromBuffer(d);\n  const pp = G.mul(dd);\n  if (pp.isInfinity()) return null;\n  const compressed = assumeCompression(__compressed);\n  return getEncoded(pp, compressed);\n}\n\nfunction pointMultiply(p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);\n  const compressed = assumeCompression(__compressed, p);\n  const pp = decodeFrom(p);\n  const tt = fromBuffer(tweak);\n  const qq = pp.mul(tt);\n  if (qq.isInfinity()) return null;\n  return getEncoded(qq, compressed);\n}\n\nfunction privateAdd(d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);\n  const dd = fromBuffer(d);\n  const tt = fromBuffer(tweak);\n  const dt = toBuffer(dd.add(tt).umod(n));\n  if (!isPrivate(dt)) return null;\n  return dt;\n}\n\nfunction privateSub(d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);\n  const dd = fromBuffer(d);\n  const tt = fromBuffer(tweak);\n  const dt = toBuffer(dd.sub(tt).umod(n));\n  if (!isPrivate(dt)) return null;\n  return dt;\n}\n\nfunction sign(hash, x) {\n  return __sign(hash, x);\n}\n\nfunction signWithEntropy(hash, x, addData) {\n  return __sign(hash, x, addData);\n}\n\nfunction __sign(hash, x, addData) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH);\n  if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE);\n  if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA);\n  const d = fromBuffer(x);\n  const e = fromBuffer(hash);\n  let r, s;\n\n  const checkSig = function (k) {\n    const kI = fromBuffer(k);\n    const Q = G.mul(kI);\n    if (Q.isInfinity()) return false;\n    r = Q.x.umod(n);\n    if (r.isZero() === 0) return false;\n    s = kI.invm(n).mul(e.add(d.mul(r))).umod(n);\n    if (s.isZero() === 0) return false;\n    return true;\n  };\n\n  deterministicGenerateK(hash, x, checkSig, isPrivate, addData); // enforce low S values, see bip62: 'low s values in signatures'\n\n  if (s.cmp(nDiv2) > 0) {\n    s = n.sub(s);\n  }\n\n  const buffer = Buffer.allocUnsafe(64);\n  toBuffer(r).copy(buffer, 0);\n  toBuffer(s).copy(buffer, 32);\n  return buffer;\n}\n\nfunction verify(hash, q, signature, strict) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH);\n  if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT); // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (1, isSignature enforces '< n - 1')\n\n  if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE);\n  const Q = decodeFrom(q);\n  const r = fromBuffer(signature.slice(0, 32));\n  const s = fromBuffer(signature.slice(32, 64));\n\n  if (strict && s.cmp(nDiv2) > 0) {\n    return false;\n  } // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (2, enforces '> 0')\n\n\n  if (r.gtn(0) <= 0\n  /* || r.compareTo(n) >= 0 */\n  ) return false;\n  if (s.gtn(0) <= 0\n  /* || s.compareTo(n) >= 0 */\n  ) return false; // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n\n  const e = fromBuffer(hash); // Compute s^-1\n\n  const sInv = s.invm(n); // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n\n  const u1 = e.mul(sInv).umod(n);\n  const u2 = r.mul(sInv).umod(n); // 1.4.5 Compute R = (xR, yR)\n  //               R = u1G + u2Q\n\n  const R = G.mulAdd(u1, Q, u2); // 1.4.5 (cont.) Enforce R is not at infinity\n\n  if (R.isInfinity()) return false; // 1.4.6 Convert the field element R.x to an integer\n\n  const xR = R.x; // 1.4.7 Set v = xR mod n\n\n  const v = xR.umod(n); // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n\n  return v.eq(r);\n}\n\nmodule.exports = {\n  isPoint,\n  isPointCompressed,\n  isPrivate,\n  pointAdd,\n  pointAddScalar,\n  pointCompress,\n  pointFromScalar,\n  pointMultiply,\n  privateAdd,\n  privateSub,\n  sign,\n  signWithEntropy,\n  verify\n};","map":{"version":3,"names":["BN","require","EC","ec","secp256k1","deterministicGenerateK","ZERO32","Buffer","alloc","EC_GROUP_ORDER","from","EC_P","n","curve","nDiv2","shrn","G","g","THROW_BAD_PRIVATE","THROW_BAD_POINT","THROW_BAD_TWEAK","THROW_BAD_HASH","THROW_BAD_SIGNATURE","THROW_BAD_EXTRA_DATA","isScalar","x","isBuffer","length","isOrderScalar","compare","isPoint","p","t","slice","decodeFrom","e","y","__isPointCompressed","isPointCompressed","isPrivate","isSignature","value","r","s","assumeCompression","pubkey","undefined","fromBuffer","d","toBuffer","toArrayLike","P","decodePoint","getEncoded","compressed","_encode","pointAdd","pA","pB","__compressed","TypeError","a","b","pp","add","isInfinity","pointAddScalar","tweak","tt","qq","mul","uu","pointCompress","pointFromScalar","dd","pointMultiply","privateAdd","dt","umod","privateSub","sub","sign","hash","__sign","signWithEntropy","addData","checkSig","k","kI","Q","isZero","invm","cmp","buffer","allocUnsafe","copy","verify","q","signature","strict","gtn","sInv","u1","u2","R","mulAdd","xR","v","eq","module","exports"],"sources":["/Users/vijithreddybheemireddi/node_modules/tiny-secp256k1/js.js"],"sourcesContent":["const BN = require('bn.js')\nconst EC = require('elliptic').ec\nconst secp256k1 = new EC('secp256k1')\nconst deterministicGenerateK = require('./rfc6979')\n\nconst ZERO32 = Buffer.alloc(32, 0)\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex')\nconst EC_P = Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex')\n\nconst n = secp256k1.curve.n\nconst nDiv2 = n.shrn(1)\nconst G = secp256k1.curve.g\n\nconst THROW_BAD_PRIVATE = 'Expected Private'\nconst THROW_BAD_POINT = 'Expected Point'\nconst THROW_BAD_TWEAK = 'Expected Tweak'\nconst THROW_BAD_HASH = 'Expected Hash'\nconst THROW_BAD_SIGNATURE = 'Expected Signature'\nconst THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)'\n\nfunction isScalar (x) {\n  return Buffer.isBuffer(x) && x.length === 32\n}\n\nfunction isOrderScalar (x) {\n  if (!isScalar(x)) return false\n  return x.compare(EC_GROUP_ORDER) < 0 // < G\n}\n\nfunction isPoint (p) {\n  if (!Buffer.isBuffer(p)) return false\n  if (p.length < 33) return false\n\n  const t = p[0]\n  const x = p.slice(1, 33)\n  if (x.compare(ZERO32) === 0) return false\n  if (x.compare(EC_P) >= 0) return false\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    try { decodeFrom(p) } catch (e) { return false } // TODO: temporary\n    return true\n  }\n\n  const y = p.slice(33)\n  if (y.compare(ZERO32) === 0) return false\n  if (y.compare(EC_P) >= 0) return false\n  if (t === 0x04 && p.length === 65) return true\n  return false\n}\n\nfunction __isPointCompressed (p) {\n  return p[0] !== 0x04\n}\n\nfunction isPointCompressed (p) {\n  if (!isPoint(p)) return false\n  return __isPointCompressed(p)\n}\n\nfunction isPrivate (x) {\n  if (!isScalar(x)) return false\n  return x.compare(ZERO32) > 0 && // > 0\n    x.compare(EC_GROUP_ORDER) < 0 // < G\n}\n\nfunction isSignature (value) {\n  const r = value.slice(0, 32)\n  const s = value.slice(32, 64)\n  return Buffer.isBuffer(value) && value.length === 64 &&\n    r.compare(EC_GROUP_ORDER) < 0 &&\n    s.compare(EC_GROUP_ORDER) < 0\n}\n\nfunction assumeCompression (value, pubkey) {\n  if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey)\n  if (value === undefined) return true\n  return value\n}\n\nfunction fromBuffer (d) { return new BN(d) }\nfunction toBuffer (d) { return d.toArrayLike(Buffer, 'be', 32) }\nfunction decodeFrom (P) { return secp256k1.curve.decodePoint(P) }\nfunction getEncoded (P, compressed) { return Buffer.from(P._encode(compressed)) }\n\nfunction pointAdd (pA, pB, __compressed) {\n  if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT)\n  if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT)\n\n  const a = decodeFrom(pA)\n  const b = decodeFrom(pB)\n  const pp = a.add(b)\n  if (pp.isInfinity()) return null\n\n  const compressed = assumeCompression(__compressed, pA)\n  return getEncoded(pp, compressed)\n}\n\nfunction pointAddScalar (p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const compressed = assumeCompression(__compressed, p)\n  const pp = decodeFrom(p)\n  if (tweak.compare(ZERO32) === 0) return getEncoded(pp, compressed)\n\n  const tt = fromBuffer(tweak)\n  const qq = G.mul(tt)\n  const uu = pp.add(qq)\n  if (uu.isInfinity()) return null\n\n  return getEncoded(uu, compressed)\n}\n\nfunction pointCompress (p, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n\n  const pp = decodeFrom(p)\n  if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT)\n\n  const compressed = assumeCompression(__compressed, p)\n\n  return getEncoded(pp, compressed)\n}\n\nfunction pointFromScalar (d, __compressed) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n\n  const dd = fromBuffer(d)\n  const pp = G.mul(dd)\n  if (pp.isInfinity()) return null\n\n  const compressed = assumeCompression(__compressed)\n  return getEncoded(pp, compressed)\n}\n\nfunction pointMultiply (p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const compressed = assumeCompression(__compressed, p)\n  const pp = decodeFrom(p)\n  const tt = fromBuffer(tweak)\n  const qq = pp.mul(tt)\n  if (qq.isInfinity()) return null\n\n  return getEncoded(qq, compressed)\n}\n\nfunction privateAdd (d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const dd = fromBuffer(d)\n  const tt = fromBuffer(tweak)\n  const dt = toBuffer(dd.add(tt).umod(n))\n  if (!isPrivate(dt)) return null\n\n  return dt\n}\n\nfunction privateSub (d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const dd = fromBuffer(d)\n  const tt = fromBuffer(tweak)\n  const dt = toBuffer(dd.sub(tt).umod(n))\n  if (!isPrivate(dt)) return null\n\n  return dt\n}\n\nfunction sign (hash, x) {\n  return __sign(hash, x)\n}\n\nfunction signWithEntropy (hash, x, addData) {\n  return __sign(hash, x, addData)\n}\n\nfunction __sign (hash, x, addData) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)\n  if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA)\n\n  const d = fromBuffer(x)\n  const e = fromBuffer(hash)\n\n  let r, s\n  const checkSig = function (k) {\n    const kI = fromBuffer(k)\n    const Q = G.mul(kI)\n\n    if (Q.isInfinity()) return false\n\n    r = Q.x.umod(n)\n    if (r.isZero() === 0) return false\n\n    s = kI\n      .invm(n)\n      .mul(e.add(d.mul(r)))\n      .umod(n)\n    if (s.isZero() === 0) return false\n\n    return true\n  }\n\n  deterministicGenerateK(hash, x, checkSig, isPrivate, addData)\n\n  // enforce low S values, see bip62: 'low s values in signatures'\n  if (s.cmp(nDiv2) > 0) {\n    s = n.sub(s)\n  }\n\n  const buffer = Buffer.allocUnsafe(64)\n  toBuffer(r).copy(buffer, 0)\n  toBuffer(s).copy(buffer, 32)\n  return buffer\n}\n\nfunction verify (hash, q, signature, strict) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)\n  if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT)\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (1, isSignature enforces '< n - 1')\n  if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE)\n\n  const Q = decodeFrom(q)\n  const r = fromBuffer(signature.slice(0, 32))\n  const s = fromBuffer(signature.slice(32, 64))\n\n  if (strict && s.cmp(nDiv2) > 0) {\n    return false\n  }\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (2, enforces '> 0')\n  if (r.gtn(0) <= 0 /* || r.compareTo(n) >= 0 */) return false\n  if (s.gtn(0) <= 0 /* || s.compareTo(n) >= 0 */) return false\n\n  // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n  const e = fromBuffer(hash)\n\n  // Compute s^-1\n  const sInv = s.invm(n)\n\n  // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n  const u1 = e.mul(sInv).umod(n)\n  const u2 = r.mul(sInv).umod(n)\n\n  // 1.4.5 Compute R = (xR, yR)\n  //               R = u1G + u2Q\n  const R = G.mulAdd(u1, Q, u2)\n\n  // 1.4.5 (cont.) Enforce R is not at infinity\n  if (R.isInfinity()) return false\n\n  // 1.4.6 Convert the field element R.x to an integer\n  const xR = R.x\n\n  // 1.4.7 Set v = xR mod n\n  const v = xR.umod(n)\n\n  // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n  return v.eq(r)\n}\n\nmodule.exports = {\n  isPoint,\n  isPointCompressed,\n  isPrivate,\n  pointAdd,\n  pointAddScalar,\n  pointCompress,\n  pointFromScalar,\n  pointMultiply,\n  privateAdd,\n  privateSub,\n  sign,\n  signWithEntropy,\n  verify\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}